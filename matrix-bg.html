<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Matrix with Scanlines</title>
    <style>
        * {
            border: none;
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            width: 100%;
            height: 100%;
            overflow: hidden;
        }

        canvas {
            background: radial-gradient(#FFF, #DDD);
            width: 100%;
            height: 100%;
            display: block;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
        }

        /* Scanlines overlay */
        .scanlines {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            z-index: 10;
            pointer-events: none;
        }
        
        .scanlines:before,
        .scanlines:after {
            display: block;
            pointer-events: none;
            content: "";
            position: absolute;
        }
        
        .scanlines:before {
            width: 100%;
            height: 2px;
            z-index: 2147483649;
            background: rgba(0, 0, 0, 0.3);
            opacity: 0.75;
            animation: scanline 13s linear infinite;
        }
        
        .scanlines:after {
            top: 0;
            right: 0;
            bottom: 0;
            left: 0;
            z-index: 2147483648;
            background: linear-gradient(
                to bottom,
                transparent 50%,
                rgba(0, 0, 0, 0.3) 51%
            );
            background-size: 100% 4px;
            animation: scanlines 10s steps(60) infinite;
        }
        
        @keyframes scanline {
            0% {
                transform: translate3d(0, -200000%, 0);
            }
            77% {
                transform: translate3d(0, 200000%, 0);
            }
            100% {
                transform: translate3d(0, 200000%, 0);
            }
        }
        
        @keyframes scanlines {
            0% {
                background-position: 0 50%;
            }
        }
    </style>
</head>
<body>
    <!-- Matrix flow field background -->
    <canvas id="matrix-canvas"></canvas>
    
    <!-- Scanlines overlay -->
    <div class="scanlines"></div>

    <script>
        var App = {};
        
        App.setup = function() {
            var canvas = document.getElementById('matrix-canvas');
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            this.canvas = canvas;
            this.ctx = this.canvas.getContext('2d');
            this.width = this.canvas.width;
            this.height = this.canvas.height;
            this.dataToImageRatio = 1;
            this.ctx.imageSmoothingEnabled = false;
            this.ctx.webkitImageSmoothingEnabled = false;
            this.ctx.msImageSmoothingEnabled = false;
            this.xC = this.width / 2;
            this.yC = this.height / 2;
            
            this.stepCount = 0;
            this.particles = [];
            this.lifespan = 2000;
            this.popPerBirth = 1;
            this.maxPop = 100;
            this.birthFreq = 10;

            // Build grid
            this.gridSize = 8;
            this.gridSteps = Math.floor(1000 / this.gridSize);
            this.grid = [];
            var i = 0;
            for (var xx = -500; xx < 500; xx += this.gridSize) {
                for (var yy = -500; yy < 500; yy += this.gridSize) {
                    var r = Math.sqrt(xx*xx+yy*yy),
                        r0 = 100,
                        field;
                    
                    // if (r < r0) field = 255 / r0 * r;
                    // else if (r > r0) field = 255 - Math.min(255, (r - r0)/2);

                    // Regular Grid Pattern
                    // field = Math.sin(xx * 0.01) * Math.cos(yy * 0.01) * 255;

                    // Option 2: Flowing Grid (Like a river)
                    // field = Math.sin(xx * 0.005 + this.stepCount * 0.01) * 255;
                    
                    // Checkerboard Pattern
                    field = ((Math.floor(xx/50) + Math.floor(yy/50)) % 2) * 255;

                    this.grid.push({
                        x: xx,
                        y: yy,
                        busyAge: 0,
                        spotIndex: i,
                        isEdge: (xx == -500 ? 'left' : 
                                (xx == (-500 + this.gridSize * (this.gridSteps-1)) ? 'right' : 
                                 (yy == -500 ? 'top' : 
                                  (yy == (-500 + this.gridSize *(this.gridSteps-1)) ? 'bottom' : 
                                   false
                                  )
                                 )
                                )
                               ),
                        field: field
                    });
                    i++;
                }
            }
            this.gridMaxIndex = i;
            
            this.deathCount = 0;
            this.initDraw();
        };

        App.evolve = function() {
            this.stepCount++;
            
            this.grid.forEach(function(e) {
                if (e.busyAge > 0) e.busyAge++;
            });
            
            if (this.stepCount % this.birthFreq == 0 && (this.particles.length + this.popPerBirth) < this.maxPop) {
                this.birth();
            }
            App.move();
            App.draw();
        };

        App.birth = function() {
            var gridSpotIndex = Math.floor(Math.random() * this.gridMaxIndex),
                gridSpot = this.grid[gridSpotIndex],
                x = gridSpot.x, y = gridSpot.y;
            
            var particle = {
                hue: 120,
                sat: 100,
                lum: 15 + Math.floor(25*Math.random()),
                x: x, y: y,
                xLast: x, yLast: y,
                xSpeed: 0, ySpeed: 0,
                age: 0,
                ageSinceStuck: 0,
                attractor: {
                    oldIndex: gridSpotIndex,
                    gridSpotIndex: gridSpotIndex,
                },
                name: 'seed-' + Math.ceil(10000000 * Math.random())
            };
            this.particles.push(particle);
        };

        App.kill = function(particleName) {
            this.particles = this.particles.filter(function(seed) {
                return seed.name !== particleName;
            });
        };

        App.move = function() {
            for (var i = 0; i < this.particles.length; i++) {
                var p = this.particles[i];
                
                p.xLast = p.x; 
                p.yLast = p.y;
                
                var index = p.attractor.gridSpotIndex,
                    gridSpot = this.grid[index];
                
                if (Math.random() < 0.1) {
                    if (!gridSpot.isEdge) {
                        var topIndex = index - 1,
                            bottomIndex = index + 1,
                            leftIndex = index - this.gridSteps,
                            rightIndex = index + this.gridSteps,
                            topSpot = this.grid[topIndex],
                            bottomSpot = this.grid[bottomIndex],
                            leftSpot = this.grid[leftIndex],
                            rightSpot = this.grid[rightIndex];
                        
                        var chaos = 30;
                        var maxField = -Infinity;
                        var maxFieldSpot = topSpot;
                        
                        [topSpot, bottomSpot, leftSpot, rightSpot].forEach(function(spot) {
                            var fieldValue = spot.field + chaos * Math.random();
                            if (fieldValue > maxField) {
                                maxField = fieldValue;
                                maxFieldSpot = spot;
                            }
                        });
                        
                        var potentialNewGridSpot = maxFieldSpot;
                        if (potentialNewGridSpot.busyAge == 0 || potentialNewGridSpot.busyAge > 15) {
                            p.ageSinceStuck = 0;
                            p.attractor.oldIndex = index;
                            p.attractor.gridSpotIndex = potentialNewGridSpot.spotIndex;
                            gridSpot = potentialNewGridSpot;
                            gridSpot.busyAge = 1;
                        } else p.ageSinceStuck++;
                        
                    } else p.ageSinceStuck++;
                    
                    if (p.ageSinceStuck == 10) this.kill(p.name);
                }
                
                var k = 8, visc = 0.4;
                var dx = p.x - gridSpot.x,
                    dy = p.y - gridSpot.y,
                    dist = Math.sqrt(dx*dx + dy*dy);
                
                var xAcc = -k * dx,
                    yAcc = -k * dy;
                
                p.xSpeed += xAcc; 
                p.ySpeed += yAcc;
                
                p.xSpeed *= visc; 
                p.ySpeed *= visc;
                
                p.speed = Math.sqrt(p.xSpeed * p.xSpeed + p.ySpeed * p.ySpeed);
                p.dist = dist;
                
                p.x += 2.0 * p.xSpeed; 
                p.y += 2.0 * p.ySpeed;
                
                p.age++;
                
                if (p.age > this.lifespan) {
                    this.kill(p.name);
                    this.deathCount++;
                }
            }
        };

        App.initDraw = function() {
            this.ctx.beginPath();
            this.ctx.rect(0, 0, this.width, this.height);
            this.ctx.fillStyle = 'black';
            this.ctx.fill();
            this.ctx.closePath();
        };

        App.draw = function() {
            if (!this.particles.length) return false;
            
            this.ctx.beginPath();
            this.ctx.rect(0, 0, this.width, this.height);
            this.ctx.fillStyle = 'rgba(0, 0, 0, 0.15)';
            this.ctx.fill();
            this.ctx.closePath();
            
            for (var i = 0; i < this.particles.length; i++) {
                var p = this.particles[i];
                
                var h = p.hue + this.stepCount/100;
                var s = p.sat;
                var l = p.lum;
                var a = 0.3;
                
                var last = this.dataXYtoCanvasXY(p.xLast, p.yLast),
                    now = this.dataXYtoCanvasXY(p.x, p.y);
                var attracSpot = this.grid[p.attractor.gridSpotIndex],
                    attracXY = this.dataXYtoCanvasXY(attracSpot.x, attracSpot.y);
                var oldAttracSpot = this.grid[p.attractor.oldIndex],
                    oldAttracXY = this.dataXYtoCanvasXY(oldAttracSpot.x, oldAttracSpot.y);
                
                this.ctx.beginPath();
                
                this.ctx.strokeStyle = 'hsla(' + h + ', ' + s + '%, ' + l + '%, ' + a + ')';
                this.ctx.fillStyle = 'hsla(' + h + ', ' + s + '%, ' + l + '%, ' + a + ')';
                
                this.ctx.moveTo(last.x, last.y);
                this.ctx.lineTo(now.x, now.y);
                
                this.ctx.lineWidth = 0.8 * this.dataToImageRatio;
                this.ctx.stroke();
                this.ctx.closePath();
                
                this.ctx.beginPath();
                this.ctx.lineWidth = 0.8 * this.dataToImageRatio;
                this.ctx.moveTo(oldAttracXY.x, oldAttracXY.y);
                this.ctx.lineTo(attracXY.x, attracXY.y);
                this.ctx.arc(attracXY.x, attracXY.y, 0.8 * this.dataToImageRatio, 0, 2 * Math.PI, false);
                
                this.ctx.strokeStyle = 'hsla(' + h + ', ' + s + '%, ' + l + '%, ' + a + ')';
                this.ctx.fillStyle = 'hsla(' + h + ', ' + s + '%, ' + l + '%, ' + a + ')';
                this.ctx.stroke();
                this.ctx.fill();
                
                this.ctx.closePath();
            }
        };

        App.dataXYtoCanvasXY = function(x, y) {
            var zoom = 1.6;
            var xx = this.xC + x * zoom * this.dataToImageRatio,
                yy = this.yC + y * zoom * this.dataToImageRatio;
            
            return {x: xx, y: yy};
        };

        // Initialize and run
        document.addEventListener('DOMContentLoaded', function() {
            App.setup();
            App.draw();
            
            var frame = function() {
                App.evolve();
                requestAnimationFrame(frame);
            };
            frame();
        });

        // Handle window resize
        window.addEventListener('resize', function() {
            App.canvas.width = window.innerWidth;
            App.canvas.height = window.innerHeight;
            App.width = App.canvas.width;
            App.height = App.canvas.height;
            App.xC = App.width / 2;
            App.yC = App.height / 2;
        });
    </script>
</body>
</html>